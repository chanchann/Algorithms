## 解体模板

https://zhuanlan.zhihu.com/p/112926891

关键词 ： return all 

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 131. Palindrome Partitioning 01 
 
全局变量：该题目要找到可分割的方案，最终结果形式上是：vector<vector<string> >
参数设计：（1）状态变量：当前是回文的字符串（2）条件变量：剩余待搜索的字符串，当字符串长度为0，则搜索完毕。
完成条件：剩余字符串长度为0。
递归过程：在剩余字符串中遍历，如果该串为回文 就 进入下次递归，如果非回文 就 继续搜索下一个串。

总共有 2^(n − 1) 种划分方案。另外对于每个方案，需要 O(n)的时间记录和判断是否回文方案。所以总时间复杂度是 O(2^n * n)

空间复杂度为 O(n)

## 40. Combination Sum II 01 

全局变量：res = []
参数设计：（1）状态变量：当前选用过的数字（2）条件变量：剩余的起始位置 和 剩余需要凑的数字
完成条件：当剩余0，就加入到res；当小于0，则不再搜索；
递归过程：如果当前剩余大于0就继续搜索。

注意如何去重

1. 首先排序

2. 重复的留到下一个递归里取，而不是开头取则重复

3. 每次i+1就是有序的，不会有无序相同组合

O(2^n * n)

O(n)

## 90. Subsets II 01 

和40大概相同，就是要去重，但是要简单一点，因为他是找出所有的可能

所以没有各种终止条件

O(2^n * n)

O(n)

## 46. Permutations 01


